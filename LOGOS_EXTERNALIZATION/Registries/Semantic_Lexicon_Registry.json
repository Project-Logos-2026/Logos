{
  "registry_name": "SEMANTIC_REGISTRY",
  "phase": 5,
  "layer": "Natural_Language_Externalization",
  "version": "1.0.0",
  "generated_at": "2026-02-09T00:00:00Z",
  "governed_by_schema": "Semantic_Registry_Schema.json",
  "entries": [
    {
      "term": "assertion_confirmed",
      "term_id": "ASSERTION_CONFIRMED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion has been formally validated through proof verification",
      "usage_constraints": "Only applies when formal validation has been completed and recorded",
      "lambda_signature": "Assertion â†’ Proof â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing validated assertion with supporting proof",
      "pxl_grounding": "â–¡ (entails ğ•† P) âˆ§ grounded_in P ğ•†",
      "pxl_constraints": "Requires existence of both assertion and proof artifacts with verified correspondence",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "assertion_negated",
      "term_id": "ASSERTION_NEGATED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion has been formally proven false",
      "usage_constraints": "Only applies when negation has been formally established through proof",
      "lambda_signature": "Assertion â†’ Proof â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing formally negated assertion with supporting proof",
      "pxl_grounding": "â–¡ (entails ğ•† (âˆ¼ P)) âˆ§ grounded_in (âˆ¼ P) ğ•†",
      "pxl_constraints": "Requires proof that establishes logical negation of the assertion",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "assertion_unproven",
      "term_id": "ASSERTION_UNPROVEN",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion lacks sufficient formal validation",
      "usage_constraints": "Only applies when proof gap has been identified and documented",
      "lambda_signature": "Assertion â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing assertion without adequate proof foundation",
      "pxl_grounding": "âˆ¼ (entails ğ•† P) âˆ§ âˆ¼ (entails ğ•† (âˆ¼ P))",
      "pxl_constraints": "Requires absence of complete proof or presence of identified proof gaps",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "conditional_satisfied",
      "term_id": "CONDITIONAL_SATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a conditional statement's preconditions have been met",
      "usage_constraints": "Only applies when all required preconditions have been formally verified",
      "lambda_signature": "Condition â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing satisfied conditional with verified preconditions",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ â–¡ P âˆ§ entails ğ•† Q",
      "pxl_constraints": "Requires verification of all antecedent conditions in the conditional statement",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "conditional_unsatisfied",
      "term_id": "CONDITIONAL_UNSATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a conditional statement's preconditions have not been met",
      "usage_constraints": "Only applies when specific precondition failures have been identified",
      "lambda_signature": "Condition â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unsatisfied conditional with unmet preconditions",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P)",
      "pxl_constraints": "Requires identification of specific unmet antecedent conditions",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "proof_confirmed",
      "term_id": "PROOF_CONFIRMED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a formal proof has been successfully validated",
      "usage_constraints": "Only applies when proof validation has been completed through formal verification",
      "lambda_signature": "Proof â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing successfully validated proof artifact",
      "pxl_grounding": "â–¡ (grounded_in P x) â†’ entails x P",
      "pxl_constraints": "Requires completion of formal verification process with positive result",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "proof_failed",
      "term_id": "PROOF_FAILED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a proof has failed validation or contains errors",
      "usage_constraints": "Only applies when specific validation failures have been identified",
      "lambda_signature": "Proof â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing failed proof validation with identified errors",
      "pxl_grounding": "âˆ¼ (grounded_in P x) âˆ¨ incoherent P",
      "pxl_constraints": "Requires identification of specific proof errors or validation failures",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "validation_incomplete",
      "term_id": "VALIDATION_INCOMPLETE",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a validation process is ongoing or incomplete",
      "usage_constraints": "Only applies when validation process has been initiated but not completed",
      "lambda_signature": "ValidationState",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing incomplete validation status",
      "pxl_grounding": "âˆ¼ â–¡ (grounded_in P x) âˆ§ âˆ¼ â–¡ (âˆ¼ (grounded_in P x))",
      "pxl_constraints": "Requires validation process to be in progress with defined completion criteria",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "scope_limitation",
      "term_id": "SCOPE_LIMITATION",
      "part_of_speech": "noun",
      "natural_language_definition": "A boundary that defines what is included or excluded from a specific domain of operation",
      "usage_constraints": "Only applies to formally defined operational or logical domains",
      "lambda_signature": "Scope â†’ Constraint",
      "lambda_role": "function",
      "lambda_notes": "Function that maps scope definitions to operational constraints",
      "pxl_grounding": "âˆƒx : Obj, â–¡ (âˆ€P, (entails x P) â†’ coherence ğ•†)",
      "pxl_constraints": "Requires explicit definition of inclusion and exclusion criteria",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "scope_violation",
      "term_id": "SCOPE_VIOLATION",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an operation exceeds established scope boundaries",
      "usage_constraints": "Only applies when specific boundary violations have been detected",
      "lambda_signature": "Scope â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing detected scope boundary violation",
      "pxl_grounding": "âˆƒP, entails x P âˆ§ âˆ¼ coherence ğ•†",
      "pxl_constraints": "Requires identification of specific boundary that has been exceeded",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "dependency_disclosure",
      "term_id": "DEPENDENCY_DISCLOSURE",
      "part_of_speech": "noun",
      "natural_language_definition": "A declaration of required dependencies for a given operation or conclusion",
      "usage_constraints": "Only applies to formally identified dependency relationships",
      "lambda_signature": "Dependency â†’ ValidationState",
      "lambda_role": "function",
      "lambda_notes": "Function that maps dependency requirements to validation states",
      "pxl_grounding": "âˆ€x y : Obj, âˆ€P : Prop, â–¡ (x â§Ÿ y) â†’ entails x P â†’ entails y P",
      "pxl_constraints": "Requires explicit identification of dependency relationships and availability",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "dependency_unsatisfied",
      "term_id": "DEPENDENCY_UNSATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that required dependencies are not available or not met",
      "usage_constraints": "Only applies when specific dependency failures have been identified",
      "lambda_signature": "Dependency â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unmet dependency requirements",
      "pxl_grounding": "âˆƒx y : Obj, âˆƒP : Prop, â–¡ (x â§Ÿ y) âˆ§ entails x P âˆ§ âˆ¼ (entails y P)",
      "pxl_constraints": "Requires identification of specific unmet dependency requirements",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "preconditions_required",
      "term_id": "PRECONDITIONS_REQUIRED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that specific preconditions must be satisfied before proceeding",
      "usage_constraints": "Only applies to operations with formally defined precondition requirements",
      "lambda_signature": "Condition â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing mandatory precondition requirements",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P)",
      "pxl_constraints": "Requires explicit definition of precondition requirements and verification methods",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "preconditions_unmet",
      "term_id": "PRECONDITIONS_UNMET",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that required preconditions have not been satisfied",
      "usage_constraints": "Only applies when specific precondition failures have been identified",
      "lambda_signature": "Condition â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unsatisfied precondition requirements",
      "pxl_grounding": "âˆƒP Q : Prop, â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P) âˆ§ â—‡ (entails ğ•† Q)",
      "pxl_constraints": "Requires identification of specific unmet precondition requirements",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "constraint_disclosure",
      "term_id": "CONSTRAINT_DISCLOSURE",
      "part_of_speech": "noun",
      "natural_language_definition": "A declaration of constraints that apply to system operations or states",
      "usage_constraints": "Only applies to formally defined system or operational constraints",
      "lambda_signature": "Constraint â†’ ValidationState",
      "lambda_role": "function",
      "lambda_notes": "Function that maps constraint definitions to enforcement states",
      "pxl_grounding": "â–¡ (âˆ€x : Obj, âˆ€y : Obj, âˆ¼ (x â§Ÿ y âˆ§ x â‡ y))",
      "pxl_constraints": "Requires explicit definition of constraint scope and enforcement mechanisms",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "constraint_violated",
      "term_id": "CONSTRAINT_VIOLATED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a system constraint has been violated or exceeded",
      "usage_constraints": "Only applies when specific constraint violations have been detected",
      "lambda_signature": "Constraint â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing detected constraint violation",
      "pxl_grounding": "âˆƒx y : Obj, (x â§Ÿ y âˆ§ x â‡ y) âˆ¨ incoherent P",
      "pxl_constraints": "Requires identification of specific constraint that has been violated",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "audit_passed",
      "term_id": "AUDIT_PASSED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an audit process has been completed successfully",
      "usage_constraints": "Only applies when formal audit process has been completed with positive result",
      "lambda_signature": "AuditResult",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing successful audit completion",
      "pxl_grounding": "â–¡ (coherence ğ•†) âˆ§ âˆ€P : Prop, grounded_in P ğ•† â†’ entails ğ•† P",
      "pxl_constraints": "Requires completion of formal audit process with documented compliance",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "audit_failed",
      "term_id": "AUDIT_FAILED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an audit process has identified compliance failures",
      "usage_constraints": "Only applies when specific audit failures have been identified and documented",
      "lambda_signature": "AuditResult",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing failed audit with identified compliance issues",
      "pxl_grounding": "âˆƒP : Prop, grounded_in P ğ•† âˆ§ âˆ¼ (entails ğ•† P) âˆ¨ âˆ¼ (coherence ğ•†)",
      "pxl_constraints": "Requires identification of specific compliance failures through formal audit",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "artifact_reference",
      "term_id": "ARTIFACT_REFERENCE",
      "part_of_speech": "noun",
      "natural_language_definition": "A formal pointer to a specific artifact with its identifying information",
      "usage_constraints": "Only applies to formally catalogued artifacts with stable identifiers",
      "lambda_signature": "Artifact â†’ Artifact",
      "lambda_role": "function",
      "lambda_notes": "Function that maps artifact identifiers to artifact objects",
      "pxl_grounding": "âˆ€x : Obj, x â§Ÿ x",
      "pxl_constraints": "Requires stable artifact identification and cataloguing system",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "technical_explanation",
      "term_id": "TECHNICAL_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation that provides implementation details and technical specifications",
      "usage_constraints": "Only applies to explanations containing formal technical content",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing technical-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚ âˆ§ entails ğ•€â‚ P",
      "pxl_constraints": "Requires inclusion of implementation-specific information and technical parameters",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "declarative_explanation",
      "term_id": "DECLARATIVE_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation that states facts directly without technical elaboration",
      "usage_constraints": "Only applies to explanations containing factual statements without interpretation",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing declarative-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚‚ âˆ§ entails ğ•€â‚‚ P",
      "pxl_constraints": "Requires direct factual content without interpretive or technical elaboration",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "pedagogical_explanation",
      "term_id": "PEDAGOGICAL_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation designed for learning and comprehension purposes",
      "usage_constraints": "Only applies to explanations structured for educational understanding",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing pedagogical-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚ƒ âˆ§ entails ğ•€â‚ƒ P",
      "pxl_constraints": "Requires structuring for learning context and comprehension goals",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    }
  ]
}