{
  "registry_name": "SEMANTIC_REGISTRY",
  "phase": 5,
  "layer": "Natural_Language_Externalization",
  "version": "1.0.0",
  "generated_at": "2026-02-09T00:00:00Z",
  "governed_by_schema": "Semantic_Registry_Schema.json",
  "entries": [
    {
      "term": "assertion_confirmed",
      "term_id": "ASSERTION_CONFIRMED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion has been formally validated through proof verification",
      "usage_constraints": "Only applies when formal validation has been completed and recorded",
      "lambda_signature": "Assertion â†’ Proof â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing validated assertion with supporting proof",
      "pxl_grounding": "â–¡ (entails ğ•† P) âˆ§ grounded_in P ğ•†",
      "pxl_constraints": "Requires existence of both assertion and proof artifacts with verified correspondence",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "assertion_negated",
      "term_id": "ASSERTION_NEGATED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion has been formally proven false",
      "usage_constraints": "Only applies when negation has been formally established through proof",
      "lambda_signature": "Assertion â†’ Proof â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing formally negated assertion with supporting proof",
      "pxl_grounding": "â–¡ (entails ğ•† (âˆ¼ P)) âˆ§ grounded_in (âˆ¼ P) ğ•†",
      "pxl_constraints": "Requires proof that establishes logical negation of the assertion",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "assertion_unproven",
      "term_id": "ASSERTION_UNPROVEN",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an assertion lacks sufficient formal validation",
      "usage_constraints": "Only applies when proof gap has been identified and documented",
      "lambda_signature": "Assertion â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing assertion without adequate proof foundation",
      "pxl_grounding": "âˆ¼ (entails ğ•† P) âˆ§ âˆ¼ (entails ğ•† (âˆ¼ P))",
      "pxl_constraints": "Requires absence of complete proof or presence of identified proof gaps",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "conditional_satisfied",
      "term_id": "CONDITIONAL_SATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a conditional statement's preconditions have been met",
      "usage_constraints": "Only applies when all required preconditions have been formally verified",
      "lambda_signature": "Condition â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing satisfied conditional with verified preconditions",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ â–¡ P âˆ§ entails ğ•† Q",
      "pxl_constraints": "Requires verification of all antecedent conditions in the conditional statement",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "conditional_unsatisfied",
      "term_id": "CONDITIONAL_UNSATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a conditional statement's preconditions have not been met",
      "usage_constraints": "Only applies when specific precondition failures have been identified",
      "lambda_signature": "Condition â†’ TruthState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unsatisfied conditional with unmet preconditions",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P)",
      "pxl_constraints": "Requires identification of specific unmet antecedent conditions",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "proof_confirmed",
      "term_id": "PROOF_CONFIRMED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a formal proof has been successfully validated",
      "usage_constraints": "Only applies when proof validation has been completed through formal verification",
      "lambda_signature": "Proof â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing successfully validated proof artifact",
      "pxl_grounding": "â–¡ (grounded_in P x) â†’ entails x P",
      "pxl_constraints": "Requires completion of formal verification process with positive result",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "proof_failed",
      "term_id": "PROOF_FAILED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a proof has failed validation or contains errors",
      "usage_constraints": "Only applies when specific validation failures have been identified",
      "lambda_signature": "Proof â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing failed proof validation with identified errors",
      "pxl_grounding": "âˆ¼ (grounded_in P x) âˆ¨ incoherent P",
      "pxl_constraints": "Requires identification of specific proof errors or validation failures",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "validation_incomplete",
      "term_id": "VALIDATION_INCOMPLETE",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a validation process is ongoing or incomplete",
      "usage_constraints": "Only applies when validation process has been initiated but not completed",
      "lambda_signature": "ValidationState",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing incomplete validation status",
      "pxl_grounding": "âˆ¼ â–¡ (grounded_in P x) âˆ§ âˆ¼ â–¡ (âˆ¼ (grounded_in P x))",
      "pxl_constraints": "Requires validation process to be in progress with defined completion criteria",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "scope_limitation",
      "term_id": "SCOPE_LIMITATION",
      "part_of_speech": "noun",
      "natural_language_definition": "A boundary that defines what is included or excluded from a specific domain of operation",
      "usage_constraints": "Only applies to formally defined operational or logical domains",
      "lambda_signature": "Scope â†’ Constraint",
      "lambda_role": "function",
      "lambda_notes": "Function that maps scope definitions to operational constraints",
      "pxl_grounding": "âˆƒx : Obj, â–¡ (âˆ€P, (entails x P) â†’ coherence ğ•†)",
      "pxl_constraints": "Requires explicit definition of inclusion and exclusion criteria",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "scope_violation",
      "term_id": "SCOPE_VIOLATION",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an operation exceeds established scope boundaries",
      "usage_constraints": "Only applies when specific boundary violations have been detected",
      "lambda_signature": "Scope â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing detected scope boundary violation",
      "pxl_grounding": "âˆƒP, entails x P âˆ§ âˆ¼ coherence ğ•†",
      "pxl_constraints": "Requires identification of specific boundary that has been exceeded",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "dependency_disclosure",
      "term_id": "DEPENDENCY_DISCLOSURE",
      "part_of_speech": "noun",
      "natural_language_definition": "A declaration of required dependencies for a given operation or conclusion",
      "usage_constraints": "Only applies to formally identified dependency relationships",
      "lambda_signature": "Dependency â†’ ValidationState",
      "lambda_role": "function",
      "lambda_notes": "Function that maps dependency requirements to validation states",
      "pxl_grounding": "âˆ€x y : Obj, âˆ€P : Prop, â–¡ (x â§Ÿ y) â†’ entails x P â†’ entails y P",
      "pxl_constraints": "Requires explicit identification of dependency relationships and availability",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "dependency_unsatisfied",
      "term_id": "DEPENDENCY_UNSATISFIED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that required dependencies are not available or not met",
      "usage_constraints": "Only applies when specific dependency failures have been identified",
      "lambda_signature": "Dependency â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unmet dependency requirements",
      "pxl_grounding": "âˆƒx y : Obj, âˆƒP : Prop, â–¡ (x â§Ÿ y) âˆ§ entails x P âˆ§ âˆ¼ (entails y P)",
      "pxl_constraints": "Requires identification of specific unmet dependency requirements",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "preconditions_required",
      "term_id": "PRECONDITIONS_REQUIRED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that specific preconditions must be satisfied before proceeding",
      "usage_constraints": "Only applies to operations with formally defined precondition requirements",
      "lambda_signature": "Condition â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing mandatory precondition requirements",
      "pxl_grounding": "â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P)",
      "pxl_constraints": "Requires explicit definition of precondition requirements and verification methods",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "preconditions_unmet",
      "term_id": "PRECONDITIONS_UNMET",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that required preconditions have not been satisfied",
      "usage_constraints": "Only applies when specific precondition failures have been identified",
      "lambda_signature": "Condition â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing unsatisfied precondition requirements",
      "pxl_grounding": "âˆƒP Q : Prop, â–¡ (P âŸ¹ Q) âˆ§ âˆ¼ (entails ğ•† P) âˆ§ â—‡ (entails ğ•† Q)",
      "pxl_constraints": "Requires identification of specific unmet precondition requirements",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "constraint_disclosure",
      "term_id": "CONSTRAINT_DISCLOSURE",
      "part_of_speech": "noun",
      "natural_language_definition": "A declaration of constraints that apply to system operations or states",
      "usage_constraints": "Only applies to formally defined system or operational constraints",
      "lambda_signature": "Constraint â†’ ValidationState",
      "lambda_role": "function",
      "lambda_notes": "Function that maps constraint definitions to enforcement states",
      "pxl_grounding": "â–¡ (âˆ€x : Obj, âˆ€y : Obj, âˆ¼ (x â§Ÿ y âˆ§ x â‡ y))",
      "pxl_constraints": "Requires explicit definition of constraint scope and enforcement mechanisms",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "constraint_violated",
      "term_id": "CONSTRAINT_VIOLATED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that a system constraint has been violated or exceeded",
      "usage_constraints": "Only applies when specific constraint violations have been detected",
      "lambda_signature": "Constraint â†’ ValidationState",
      "lambda_role": "state",
      "lambda_notes": "Terminal state representing detected constraint violation",
      "pxl_grounding": "âˆƒx y : Obj, (x â§Ÿ y âˆ§ x â‡ y) âˆ¨ incoherent P",
      "pxl_constraints": "Requires identification of specific constraint that has been violated",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "audit_passed",
      "term_id": "AUDIT_PASSED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an audit process has been completed successfully",
      "usage_constraints": "Only applies when formal audit process has been completed with positive result",
      "lambda_signature": "AuditResult",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing successful audit completion",
      "pxl_grounding": "â–¡ (coherence ğ•†) âˆ§ âˆ€P : Prop, grounded_in P ğ•† â†’ entails ğ•† P",
      "pxl_constraints": "Requires completion of formal audit process with documented compliance",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "audit_failed",
      "term_id": "AUDIT_FAILED",
      "part_of_speech": "state",
      "natural_language_definition": "A semantic state indicating that an audit process has identified compliance failures",
      "usage_constraints": "Only applies when specific audit failures have been identified and documented",
      "lambda_signature": "AuditResult",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing failed audit with identified compliance issues",
      "pxl_grounding": "âˆƒP : Prop, grounded_in P ğ•† âˆ§ âˆ¼ (entails ğ•† P) âˆ¨ âˆ¼ (coherence ğ•†)",
      "pxl_constraints": "Requires identification of specific compliance failures through formal audit",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "artifact_reference",
      "term_id": "ARTIFACT_REFERENCE",
      "part_of_speech": "noun",
      "natural_language_definition": "A formal pointer to a specific artifact with its identifying information",
      "usage_constraints": "Only applies to formally catalogued artifacts with stable identifiers",
      "lambda_signature": "Artifact â†’ Artifact",
      "lambda_role": "function",
      "lambda_notes": "Function that maps artifact identifiers to artifact objects",
      "pxl_grounding": "âˆ€x : Obj, x â§Ÿ x",
      "pxl_constraints": "Requires stable artifact identification and cataloguing system",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "technical_explanation",
      "term_id": "TECHNICAL_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation that provides implementation details and technical specifications",
      "usage_constraints": "Only applies to explanations containing formal technical content",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing technical-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚ âˆ§ entails ğ•€â‚ P",
      "pxl_constraints": "Requires inclusion of implementation-specific information and technical parameters",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "declarative_explanation",
      "term_id": "DECLARATIVE_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation that states facts directly without technical elaboration",
      "usage_constraints": "Only applies to explanations containing factual statements without interpretation",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing declarative-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚‚ âˆ§ entails ğ•€â‚‚ P",
      "pxl_constraints": "Requires direct factual content without interpretive or technical elaboration",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "pedagogical_explanation",
      "term_id": "PEDAGOGICAL_EXPLANATION",
      "part_of_speech": "noun",
      "natural_language_definition": "An explanation designed for learning and comprehension purposes",
      "usage_constraints": "Only applies to explanations structured for educational understanding",
      "lambda_signature": "Explanation",
      "lambda_role": "constant",
      "lambda_notes": "Constant representing pedagogical-level explanation content",
      "pxl_grounding": "grounded_in P ğ•€â‚ƒ âˆ§ entails ğ•€â‚ƒ P",
      "pxl_constraints": "Requires structuring for learning context and comprehension goals",
      "status": "canonical",
      "introduced_in_version": "1.0.0"
    },
    {
      "term": "mod_epistemic_assertion",
      "term_id": "MOD_EPISTEMIC_ASSERTION",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies assertion-category AXIOM output with an explicit epistemic status marker, rendering the knowledge state without altering truth value",
      "usage_constraints": "Applies only to Assertion-category AXIOM templates (ASSERTION_CONFIRMED, ASSERTION_NEGATED, ASSERTION_UNPROVEN). Must not alter the assertion's truth value. Epistemic status is determined upstream.",
      "lambda_signature": "Assertion â†’ EpistemicStatus â†’ Assertion",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over assertion output. Takes an assertion state and epistemic status, returns qualified assertion. Non-assertive: does not introduce new truth claims.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, entails x P â†’ (grounded_in P x â†’ K x P) âˆ§ entails x P",
      "pxl_constraints": "Preserves entails x P from base AXIOM. Epistemic layer derived from Perfect_self_knowledge (PXL_Kernel_Axioms.v): grounded_in p x â†’ K x p. Modifier renders K x P status without asserting or negating it.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_epistemic_conditional",
      "term_id": "MOD_EPISTEMIC_CONDITIONAL",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies conditional-category AXIOM output with an explicit epistemic status marker, rendering the knowledge state without altering conditional truth value",
      "usage_constraints": "Applies only to Conditional-category AXIOM templates (CONDITIONAL_SATISFIED, CONDITIONAL_UNSATISFIED). Must not alter the conditional's truth value.",
      "lambda_signature": "Condition â†’ EpistemicStatus â†’ Condition",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over conditional output. Non-assertive.",
      "pxl_grounding": "âˆ€P Q : Prop, âˆ€x : Obj, â–¡ (P âŸ¹ Q) â†’ (grounded_in P x â†’ K x P) âˆ§ â–¡ (P âŸ¹ Q)",
      "pxl_constraints": "Preserves â–¡ (P âŸ¹ Q) from base AXIOM. Epistemic layer adds K x P qualification via Perfect_self_knowledge. Does not alter conditional relationship.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_epistemic_proof",
      "term_id": "MOD_EPISTEMIC_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies proof-category AXIOM output with an explicit epistemic status marker, rendering the knowledge state without altering proof validation status",
      "usage_constraints": "Applies only to Proof-category AXIOM templates (PROOF_CONFIRMED, PROOF_FAILED, VALIDATION_INCOMPLETE). Must not alter proof status.",
      "lambda_signature": "Proof â†’ EpistemicStatus â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over proof output. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, grounded_in P x â†’ K x P âˆ§ entails x P",
      "pxl_constraints": "Composed from grounding_yields_entails (grounded_in P x â†’ entails x P) and Perfect_self_knowledge (grounded_in p x â†’ K x p). Both from PXL_Kernel_Axioms.v. Preserves base proof state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_scope_assertion",
      "term_id": "MOD_SCOPE_ASSERTION",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that restricts the rendered scope of assertion-category AXIOM output by making explicit the scope boundaries determined in the upstream meaning state",
      "usage_constraints": "Applies only to Assertion-category AXIOM templates. Must not introduce scope not present in the meaning state.",
      "lambda_signature": "Assertion â†’ Scope â†’ Assertion",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Scope restriction narrows rendering, does not alter truth. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x y : Obj, entails x P â†’ â–¡ (x â§Ÿ y) â†’ entails y P âˆ§ entails x P",
      "pxl_constraints": "Uses modus_groundens (PXL_Kernel_Axioms.v): â–¡ (x â§Ÿ y) â†’ entails x P â†’ entails y P. Scope restriction renders the identity-bounded transport of entailment. Preserves base entailment.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_scope_conditional",
      "term_id": "MOD_SCOPE_CONDITIONAL",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that restricts the rendered scope of conditional-category AXIOM output by making explicit the scope boundaries determined in the upstream meaning state",
      "usage_constraints": "Applies only to Conditional-category AXIOM templates. Must not introduce scope not present in the meaning state.",
      "lambda_signature": "Condition â†’ Scope â†’ Condition",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P Q : Prop, âˆ€x y : Obj, â–¡ (P âŸ¹ Q) â†’ â–¡ (x â§Ÿ y) â†’ entails y Q âˆ§ â–¡ (P âŸ¹ Q)",
      "pxl_constraints": "Composes modus_groundens with conditional preservation. Scope restriction bounds the domain of conditional applicability. Preserves â–¡ (P âŸ¹ Q).",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_scope_proof",
      "term_id": "MOD_SCOPE_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that restricts the rendered scope of proof-category AXIOM output by making explicit the scope boundaries determined in the upstream meaning state",
      "usage_constraints": "Applies only to Proof-category AXIOM templates. Must not introduce scope not present in the meaning state.",
      "lambda_signature": "Proof â†’ Scope â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x y : Obj, grounded_in P x â†’ â–¡ (x â§Ÿ y) â†’ entails y P âˆ§ grounded_in P x",
      "pxl_constraints": "Composes grounding_yields_entails and modus_groundens. Scope restriction renders the identity-bounded domain of proof validity. Preserves grounding.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_scope_dependency",
      "term_id": "MOD_SCOPE_DEPENDENCY",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that restricts the rendered scope of dependency-category AXIOM output by making explicit the scope boundaries determined in the upstream meaning state",
      "usage_constraints": "Applies only to Dependency-category AXIOM templates. Must not introduce scope not present in the meaning state.",
      "lambda_signature": "Dependency â†’ Scope â†’ Dependency",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€x y z : Obj, âˆ€P : Prop, â–¡ (x â§Ÿ y) â†’ entails x P â†’ â–¡ (y â§Ÿ z) â†’ entails z P âˆ§ entails x P",
      "pxl_constraints": "Chains modus_groundens twice. Scope restriction renders the transitive identity-bounded domain of dependency relationships. Preserves base dependency entailment.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_scope_constraint",
      "term_id": "MOD_SCOPE_CONSTRAINT",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that restricts the rendered scope of constraint-category AXIOM output by making explicit the scope boundaries determined in the upstream meaning state",
      "usage_constraints": "Applies only to Constraint-category AXIOM templates. Must not introduce scope not present in the meaning state.",
      "lambda_signature": "Constraint â†’ Scope â†’ Constraint",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€x y : Obj, â–¡ (âˆ¼ (x â§Ÿ y âˆ§ x â‡ y)) â†’ âˆ€z : Obj, â–¡ (x â§Ÿ z) â†’ â–¡ (âˆ¼ (z â§Ÿ y âˆ§ z â‡ y)) âˆ§ â–¡ (âˆ¼ (x â§Ÿ y âˆ§ x â‡ y))",
      "pxl_constraints": "Composes A2_noncontradiction pattern with identity transport via modus_groundens. Scope restriction renders the domain over which the non-contradiction constraint holds. Preserves base constraint.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_assertion",
      "term_id": "MOD_TEMPORAL_ASSERTION",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies assertion-category AXIOM output with a temporal validity marker, projecting the modal status of the entailment as a temporal frame",
      "usage_constraints": "Applies only to Assertion-category AXIOM templates. Must not alter truth value. Temporal marker frames when the state was established.",
      "lambda_signature": "Assertion â†’ TemporalFrame â†’ Assertion",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Temporal framing maps to PXL modal status (â–¡ vs â—‡). Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, entails x P â†’ (â–¡ (entails x P) âˆ¨ â—‡ (entails x P)) âˆ§ entails x P",
      "pxl_constraints": "Projects modal status of base entailment using â–¡ and â—‡ (PXL_Modal_Axioms_Semantic.v). Necessary entailment (â–¡) maps to persistent temporal validity; contingent entailment (â—‡) maps to bounded temporal validity. Preserves base entailment.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_conditional",
      "term_id": "MOD_TEMPORAL_CONDITIONAL",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies conditional-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Conditional-category AXIOM templates. Must not alter conditional truth value.",
      "lambda_signature": "Condition â†’ TemporalFrame â†’ Condition",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P Q : Prop, â–¡ (P âŸ¹ Q) â†’ (â–¡ â–¡ (P âŸ¹ Q) âˆ¨ â—‡ (P âŸ¹ Q)) âˆ§ â–¡ (P âŸ¹ Q)",
      "pxl_constraints": "Projects modal status of conditional using â–¡ and â—‡. Uses ax_4 derivation (â–¡ p â†’ â–¡ â–¡ p) for necessary persistence. Preserves base conditional.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_proof",
      "term_id": "MOD_TEMPORAL_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies proof-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Proof-category AXIOM templates. Must not alter proof status.",
      "lambda_signature": "Proof â†’ TemporalFrame â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, grounded_in P x â†’ (â–¡ (grounded_in P x) âˆ¨ â—‡ (grounded_in P x)) âˆ§ entails x P",
      "pxl_constraints": "Projects modal status of grounding relationship using â–¡ and â—‡. Entailment preserved via grounding_yields_entails (PXL_Kernel_Axioms.v). Preserves base proof state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_scope",
      "term_id": "MOD_TEMPORAL_SCOPE",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies scope-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Scope-category AXIOM templates. Must not alter scope boundaries.",
      "lambda_signature": "Scope â†’ TemporalFrame â†’ Scope",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€x : Obj, âˆ€P : Prop, (entails x P â†’ coherence ğ•†) â†’ (â–¡ (entails x P â†’ coherence ğ•†) âˆ¨ â—‡ (entails x P â†’ coherence ğ•†))",
      "pxl_constraints": "Projects modal status of scope-bounded coherence relationship. Uses coherence_lifts_entailment pattern (PXL_Kernel_Axioms.v). Preserves base scope definition.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_dependency",
      "term_id": "MOD_TEMPORAL_DEPENDENCY",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies dependency-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Dependency-category AXIOM templates. Must not alter dependency relationships.",
      "lambda_signature": "Dependency â†’ TemporalFrame â†’ Dependency",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€x y : Obj, âˆ€P : Prop, â–¡ (x â§Ÿ y) â†’ entails x P â†’ (â–¡ (entails y P) âˆ¨ â—‡ (entails y P)) âˆ§ entails x P",
      "pxl_constraints": "Projects modal status of dependency-transported entailment via modus_groundens (PXL_Kernel_Axioms.v). Preserves base dependency entailment.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_constraint",
      "term_id": "MOD_TEMPORAL_CONSTRAINT",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies constraint-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Constraint-category AXIOM templates. Must not alter constraint definitions.",
      "lambda_signature": "Constraint â†’ TemporalFrame â†’ Constraint",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€x y : Obj, â–¡ (âˆ¼ (x â§Ÿ y âˆ§ x â‡ y)) â†’ â–¡ â–¡ (âˆ¼ (x â§Ÿ y âˆ§ x â‡ y)) âˆ§ â–¡ (âˆ¼ (x â§Ÿ y âˆ§ x â‡ y))",
      "pxl_constraints": "A2_noncontradiction is already necessarily necessary (â–¡ â–¡ by ax_4 derivation). Temporal qualification of constraints renders this modal fact. Preserves base constraint.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_temporal_audit",
      "term_id": "MOD_TEMPORAL_AUDIT",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that qualifies audit-category AXIOM output with a temporal validity marker",
      "usage_constraints": "Applies only to Audit-category AXIOM templates. Must not alter audit result.",
      "lambda_signature": "AuditResult â†’ TemporalFrame â†’ AuditResult",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, (coherence ğ•† â†’ entails ğ•† P) â†’ (â–¡ (coherence ğ•† â†’ entails ğ•† P) âˆ¨ â—‡ (coherence ğ•† â†’ entails ğ•† P))",
      "pxl_constraints": "Projects modal status of coherence-conditional global entailment. Uses coherence_lifts_entailment and A7_triune_necessity patterns (PXL_Kernel_Axioms.v). Preserves base audit state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_strength_assertion",
      "term_id": "MOD_STRENGTH_ASSERTION",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that adjusts the assertoric force of assertion-category AXIOM output from necessary through provisional to indicated, driven by Semantic State Condition classification",
      "usage_constraints": "Applies only to Assertion-category AXIOM templates. Must not alter truth value. Strength is determined by SSC: COMPLETE=necessary, PARTIAL=provisional, UNRESOLVED=indicated.",
      "lambda_signature": "Assertion â†’ StrengthLevel â†’ Assertion",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Selects among surface variants expressing different assertoric force. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, entails x P â†’ (â–¡ (entails ğ•† P) âˆ¨ (â—‡ (entails ğ•† P) âˆ§ âˆ¼ â–¡ (entails ğ•† P))) âˆ§ entails x P",
      "pxl_constraints": "Necessary strength: â–¡ (entails ğ•† P) via coherence_lifts_entailment. Provisional strength: â—‡ (entails ğ•† P) âˆ§ âˆ¼ â–¡ (entails ğ•† P), possible but not necessary global entailment. Base entailment preserved.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_strength_conditional",
      "term_id": "MOD_STRENGTH_CONDITIONAL",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that adjusts the assertoric force of conditional-category AXIOM output",
      "usage_constraints": "Applies only to Conditional-category AXIOM templates. Must not alter conditional truth value.",
      "lambda_signature": "Condition â†’ StrengthLevel â†’ Condition",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P Q : Prop, â–¡ (P âŸ¹ Q) â†’ (â–¡ (entails ğ•† Q) âˆ¨ â—‡ (entails ğ•† Q)) âˆ§ â–¡ (P âŸ¹ Q)",
      "pxl_constraints": "Strength modulates whether the conditional's consequent achieves global entailment necessarily or contingently. Uses coherence_lifts_entailment pattern. Preserves base conditional.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_strength_proof",
      "term_id": "MOD_STRENGTH_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that adjusts the assertoric force of proof-category AXIOM output",
      "usage_constraints": "Applies only to Proof-category AXIOM templates. Must not alter proof status.",
      "lambda_signature": "Proof â†’ StrengthLevel â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, grounded_in P x â†’ (â–¡ (entails ğ•† P) âˆ¨ â—‡ (entails ğ•† P)) âˆ§ grounded_in P x",
      "pxl_constraints": "Strength modulates whether grounded proof achieves global entailment necessarily or contingently. Uses coherence_lifts_entailment and grounding_yields_entails. Preserves base grounding.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_dependency_assertion",
      "term_id": "MOD_DEPENDENCY_ASSERTION",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that renders explicit dependency conditions on assertion-category AXIOM output, making visible dependency relationships already present in the upstream meaning state",
      "usage_constraints": "Applies only to Assertion-category AXIOM templates. Must not introduce dependencies not present in the meaning state.",
      "lambda_signature": "Assertion â†’ Dependency â†’ Assertion",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Renders existing dependencies, does not create them. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x y : Obj, entails x P â†’ â–¡ (x â§Ÿ y) â†’ entails y P âˆ§ entails x P",
      "pxl_constraints": "Directly applies modus_groundens (PXL_Kernel_Axioms.v). Renders the identity-based dependency transport that conditions the assertion. Preserves base assertion entailment.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_dependency_conditional",
      "term_id": "MOD_DEPENDENCY_CONDITIONAL",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that renders explicit dependency conditions on conditional-category AXIOM output",
      "usage_constraints": "Applies only to Conditional-category AXIOM templates. Must not introduce dependencies not present in the meaning state.",
      "lambda_signature": "Condition â†’ Dependency â†’ Condition",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P Q : Prop, âˆ€x y : Obj, â–¡ (P âŸ¹ Q) â†’ â–¡ (x â§Ÿ y) â†’ entails x P â†’ entails y P âˆ§ â–¡ (P âŸ¹ Q)",
      "pxl_constraints": "Composes modus_groundens with conditional preservation. Renders identity-based dependency that conditions the conditional's evaluation context. Preserves base conditional.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_dependency_proof",
      "term_id": "MOD_DEPENDENCY_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that renders explicit dependency conditions on proof-category AXIOM output",
      "usage_constraints": "Applies only to Proof-category AXIOM templates. Must not introduce dependencies not present in the meaning state.",
      "lambda_signature": "Proof â†’ Dependency â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x y : Obj, grounded_in P x â†’ â–¡ (x â§Ÿ y) â†’ entails y P âˆ§ grounded_in P x",
      "pxl_constraints": "Composes grounding_yields_entails and modus_groundens. Renders grounding-based dependency that conditions proof validity. Preserves base grounding.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_remediation_proof",
      "term_id": "MOD_REMEDIATION_PROOF",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that attaches remediation guidance to PROOF_FAILED AXIOM output, rendering a resolution path without claiming resolution has occurred",
      "usage_constraints": "Applies only to PROOF_FAILED within the Proof category. Must not alter failure state. Remediation is descriptive, not prescriptive.",
      "lambda_signature": "Proof â†’ RemediationPath â†’ Proof",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over failure state. Non-assertive. Does not claim resolution.",
      "pxl_grounding": "âˆ€P : Prop, (âˆ¼ (grounded_in P x) âˆ¨ incoherent P) â†’ âˆ¼ (incoherent P) â†’ â—‡ (entails ğ•† P)",
      "pxl_constraints": "From NB_modal_power (PXL_Kernel_Axioms.v): â–¡ (âˆ€Ï† : Prop, âˆ¼ (incoherent Ï†) â†’ â—‡ (entails ğ•† Ï†)). If the failed proof's content is not incoherent, remediation is possible (â—‡). Privative_collapse (âˆ¼ (â—‡ (entails ğ•† P)) â†’ incoherent P) provides the boundary: if incoherent, no remediation. Preserves failure state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_remediation_scope",
      "term_id": "MOD_REMEDIATION_SCOPE",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that attaches remediation guidance to SCOPE_VIOLATION AXIOM output, rendering a resolution path without claiming resolution has occurred",
      "usage_constraints": "Applies only to SCOPE_VIOLATION within the Scope category. Must not alter violation state.",
      "lambda_signature": "Scope â†’ RemediationPath â†’ Scope",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over violation state. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, âˆ€x : Obj, (entails x P âˆ§ âˆ¼ (coherence ğ•†)) â†’ âˆ¼ (incoherent P) â†’ â—‡ (entails ğ•† P)",
      "pxl_constraints": "Scope violation implies local entailment without global coherence. NB_modal_power provides: if non-incoherent, possible global entailment exists as remediation target. Preserves violation state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_remediation_dependency",
      "term_id": "MOD_REMEDIATION_DEPENDENCY",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that attaches remediation guidance to DEPENDENCY_UNSATISFIED and PRECONDITIONS_UNMET AXIOM output, rendering a resolution path without claiming resolution has occurred",
      "usage_constraints": "Applies only to DEPENDENCY_UNSATISFIED and PRECONDITIONS_UNMET within the Dependency category. Must not alter unsatisfied state.",
      "lambda_signature": "Dependency â†’ RemediationPath â†’ Dependency",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over unsatisfied state. Non-assertive.",
      "pxl_grounding": "âˆ€x y : Obj, âˆ€P : Prop, (â–¡ (x â§Ÿ y) âˆ§ entails x P âˆ§ âˆ¼ (entails y P)) â†’ âˆ¼ (incoherent P) â†’ â—‡ (entails y P)",
      "pxl_constraints": "Unsatisfied dependency: identity-linked objects where entailment does not transport. NB_modal_power provides: if non-incoherent, possible entailment at target exists as remediation path. Preserves unsatisfied state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_remediation_constraint",
      "term_id": "MOD_REMEDIATION_CONSTRAINT",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that attaches remediation guidance to CONSTRAINT_VIOLATED AXIOM output, rendering a resolution path without claiming resolution has occurred",
      "usage_constraints": "Applies only to CONSTRAINT_VIOLATED within the Constraint category. Must not alter violation state.",
      "lambda_signature": "Constraint â†’ RemediationPath â†’ Constraint",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over violation state. Non-assertive.",
      "pxl_grounding": "âˆ€x y : Obj, (x â§Ÿ y âˆ§ x â‡ y) â†’ âˆ¼ (incoherent (coherence ğ•†)) â†’ â—‡ (coherence ğ•†)",
      "pxl_constraints": "Constraint violation (x â§Ÿ y âˆ§ x â‡ y) contradicts A2_noncontradiction. Remediation targets coherence restoration. NB_modal_power: if coherence is not incoherent, â—‡ (coherence ğ•†). A7_triune_necessity (â–¡ (coherence ğ•†)) provides the ultimate remediation anchor. Preserves violation state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    },
    {
      "term": "mod_remediation_audit",
      "term_id": "MOD_REMEDIATION_AUDIT",
      "part_of_speech": "operator",
      "natural_language_definition": "A modifier function that attaches remediation guidance to AUDIT_FAILED AXIOM output, rendering a resolution path without claiming resolution has occurred",
      "usage_constraints": "Applies only to AUDIT_FAILED within the Audit category. Must not alter failure state.",
      "lambda_signature": "AuditResult â†’ RemediationPath â†’ AuditResult",
      "lambda_role": "function",
      "lambda_notes": "Higher-order function over audit failure state. Non-assertive.",
      "pxl_grounding": "âˆ€P : Prop, (grounded_in P ğ•† âˆ§ âˆ¼ (entails ğ•† P)) âˆ¨ âˆ¼ (coherence ğ•†) â†’ âˆ¼ (incoherent P) â†’ â—‡ (entails ğ•† P)",
      "pxl_constraints": "Audit failure: either grounding-entailment gap or coherence failure. NB_modal_power: non-incoherent content has possible global entailment. A7_triune_necessity (â–¡ (coherence ğ•†)) anchors that coherence is necessarily attainable. Preserves audit failure state.",
      "status": "canonical",
      "introduced_in_version": "1.1.0"
    }
  ]
}